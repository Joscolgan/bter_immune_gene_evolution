#!/usr/bin/env Rscript
#######################################################################
##
## Author: Joe Colgan (joscolgan)          Program: plot_pca.R
##
## Date:   10/04/22
##
## Purpose:  
## This script takes a VCF file as input (VCF generated by Freebayes) and using gdsfmt generates a 
## genotype matrix.
## Using this genotypic matrix, SNPRelate performs LD pruning, PCA and identity by state to
## assess relatedness amongst individuals.
## The output is a number of ggplots for:
## - A scatterplot of first two principal components.
## - A scatterplot for IBD co-efficients for each individual in the dataset.
## The script also loads output files generated by ADMIXTURE which provides
## cross validation error rates for estimation of population substructure.
## Then script generates a number of plots that are arranged into a multi-panel plot by the R package
## ggpubr. This plot is then output as a PDF.
##
#######################################################################

# Load libraries; install from scratch if needed
libraries <- c("gdsfmt",
               "SNPRelate",
               "ggplot2",
               "ggpubr",
               "reshape2")
for (lib in libraries) {
    if (require(package = lib, character.only = TRUE)) {
        print("Successful")
    } else {
        print("Installing")
        source("https://bioconductor.org/biocLite.R")
        library(lib, character.only = TRUE )
    }
}

## Create output directory:
dir.create("results")

## Take arguments from the command line:
## Provide access to a copy of the command line arguments supplied when R session is invoked
args <- commandArgs(TRUE)
input        <- args[1] 						# Assign first argument as input
output       <- args[2]
slide_max    <- args[3]
slide_snp    <- args[4]
ld_threshold <- args[5]
slide_max <- as.numeric(slide_max)
slide_snp <- as.numeric(slide_snp)
ld_threshold <- as.numeric(ld_threshold)

## Load data and perform PCA:
## Plot PCA of larger number of samples (n=46):
## Assign the input name:  
input_vcf <- input

## Convert VCF to genome data structure (gds) file format
## gds is a container for storing annotation data and SNP genotypes.
## In this format, each byte encodes up to four SNP genotypes thereby reducing file size and access time.
## The GDS format supports data blocking so that only the subset of data that is being processed needs
## to reside in memory. GDS formatted data is also designed for efficient data access to large datasets.

## Use the name of input to designate the name for the GDS file format.
input_vcf_gds <- gsub(".vcf",
                      ".gds",
                      input_vcf)

## Reformat VCF into GDS format
snpgdsVCF2GDS(input_vcf,
              input_vcf_gds,
              method = "biallelic.only")

## Extract genotype information:
input_vcf_gds_genofile <- snpgdsOpen(input_vcf_gds)
print("extracted genotype information")

## Extract genotype information and generate genotypic matrix:  
input_vcf_gds_genofile_matrix <- read.gdsn(index.gdsn(input_vcf_gds_genofile,
                                                      "genotype"))
                                                      
## For performing PCA, it is recommended to perform LD pruning:
snpset <- snpgdsLDpruning(input_vcf_gds_genofile,
                          slide.max.bp = slide_max,
                          slide.max.n = slide_snp,
                          ld.threshold = ld_threshold,
                          autosome.only = FALSE)
print(class(snpset))

## Perform PCA and store output in variable:  
pca        <- snpgdsPCA(input_vcf_gds_genofile,
                          num.thread = 40,
                          snp.id = snpset.id,
                          autosome.only = FALSE)

## Calculate percentages for principal components:  
pc_percent      <- pca$varprop * 100
## Print rounded up percentages:
print(round(pc_percent, 2))

## Extract sample names from input:  
sample_id     <- read.gdsn(index.gdsn(input_vcf_gds_genofile,
                                      "sample.id"))

## Generate a dataframe containing a column for:
## 1) Sample name
## 2) Treatment condition
## 3) First principal component of interest
## 4) Second principal component of interest
tab <- data.frame(sample.id = pca$sample.id,
                  #pop = factor(pop_code)[match(pca$sample.id, sample_id)],
                  EV1 = pca$eigenvect[, 1],    # the first eigenvector
                  EV2 = pca$eigenvect[, 2],    # the second eigenvector
                  stringsAsFactors = FALSE)

## Rename the samples for plotting:  
new_names <- list()

## Create a list:
for (name in sample_id){
        new_names[name] <- paste(strsplit(name, "_")[[1]][1],
        "_", strsplit(name, "_")[[1]][2],
        sep = "")
}

## Unlist as a character string and update sample ids:
tab$sample.id <- as.character(unlist(new_names))

## Update site information: 
tab$site_id <- new_site_id

## Generate a basic plot:
pca_plot <- ggplot(tab,
                    aes(x = EV1,
                        y = EV2)) +
        geom_point(shape = 16,
                   size = 4,
                   alpha = 0.4,
                   show.legend = TRUE) +
        theme_minimal() +
        xlab(paste("Principal component",
                   1,
                   " ",
                   "(",
                   round(pc_percent[1],
                         2), "%", ")",
                   sep = "")) +
        ylab(paste("Principal component",
                   2,
                   " ",
                   "(",
                   round(pc_percent[2],
                         2), "%", ")",
                   sep = "")) +
              theme(axis.text = element_text(size = 10),
                    axis.title = element_text(size = 12,
                                            face = "bold")) +
                    theme(legend.position = "none")

## Explore relatedness among individuals:
## Identity by state:
ibs <- snpgdsIBS(input_vcf_gds_genofile,
                 num.thread = 20,
                 snp.id = snpset.id,
                 autosome.only = FALSE)

## Order samples by population information:
input_for_melt <- as.data.frame(ibs$ibs)
colnames(input_for_melt) <- tab$sample.id
rownames(input_for_melt) <- tab$sample.id
input_for_melt$sample <- tab$sample.id
input_for_melt_melted <- melt(input_for_melt)

colnames(input_for_melt_melted) <- tab$sample.id
rownames(input_for_melt_melted) <- tab$sample.id

input_for_melt_melted$sample <- factor(input_for_melt_melted$sample,
                                          levels = unique(input_for_melt_melted$variable))

## Generate plot:
ibs_plot <- ggplot(data = input_for_melt_melted,
                   aes(x = sample,
                       y = variable,
                       fill = value)) +
    xlab("Samples") +
    ylab("Samples") +
    geom_tile(colour = "black") +
    theme(axis.text.x = element_text(angle = 90,
                                     hjust = 1),
          axis.title = element_text(size = 15,
                                    face = "bold")) +
    scale_fill_gradient("r-value",
                        low = "orange",
                        high = "black",
                        breaks = c(0.7,
                                   0.8,
                                   0.9,
                                   1),
                        labels = c("0.7",
                                   "0.8",
                                   "0.9",
                                   "1"),
                        limits = c(0.7,
                                   1)) +
    theme(axis.title = element_blank(),
          legend.position = "top")

## Read in results from ADMIXTURE:
cv_error_rates <- read.table(file = "results/cv_error_rate.txt",
                             header = FALSE)

## Add column names:
cv_error_rates$V1 <- NULL
cv_error_rates$V2 <- NULL
cv_error_rates$V3 <- gsub(pattern = "[(]K=",
                          replacement = "",
                          cv_error_rates$V3)

cv_error_rates$V3 <- gsub(pattern = "[)]",
                          replacement = "",
                          cv_error_rates$V3)

## 
colnames(cv_error_rates) <- c("K",
                              "CV_error_rate")

## Reorder:
str(cv_error_rates)
cv_error_rates$K <- as.numeric(cv_error_rates$K)
cv_error_rates_ordered <- cv_error_rates[order(cv_error_rates$K),]

## Generate plot:
cv_error_plot <- ggplot(data = cv_error_rates_ordered,
                        aes(x = K,
                            y = CV_error_rate)) +
    geom_point() +
    xlab(expression(italic("K"))) +
    ylab(label = "Cross validation error") +
    theme_bw() +
    theme(axis.title = element_text(face = "bold",
                                    size = 12))

## Read in estimated likelihoods per K:
likelihood_rates <- read.table(file = "results/likelihood_rate.txt",
                             header = FALSE)

## Format:
likelihood_rates$V1 <- gsub(pattern = "[.]out:Loglikelihood:",
                            replacement = "",
                            likelihood_rates$V1)

likelihood_rates$V1 <- gsub(pattern = "log",
                            replacement = "",
                            likelihood_rates$V1)

colnames(likelihood_rates) <- c("K",
                                "Estimated_likelihood")

likelihood_rates$K <- as.numeric(likelihood_rates$K)
likelihood_rates_ordered <- likelihood_rates[order(likelihood_rates$K),]

likelihood_rates_plot <- ggplot(data = likelihood_rates_ordered,
                        aes(x = K,
                            y = Estimated_likelihood)) +
    geom_point() +
    xlab(expression(italic("K"))) +
    ylab(label = "Estimated loglikelihood") +
    theme_bw() +
    theme(axis.title = element_text(face = "bold",
                                    size = 12))


## Combine plot:
ggarrange(pca_plot,
          ibs_plot,
          cv_error_plot,
          likelihood_rates_plot,
          ncol = 2,
          nrow = 2,
          align = "hv",
          labels = c("A",
                     "B",
                     "C",
                     "D"))

## Save object:
ggsave(filename = output,
       height = 10,
       width = 10,
       dpi = 600)
